# Import necessary modules and libraries
# langchain: Used for creating and managing AI agents and tools
# openvino_genai: Used for initializing and using OpenVINO's LLM pipeline
# smtplib, email.mime: Used for sending emails via SMTP
# dotenv: Used for loading environment variables from a .env file
# os: Provides functions to interact with the operating system
from langchain.agents import initialize_agent, Tool, AgentExecutor, AgentType
from langchain.tools import StructuredTool
from langchain.llms.base import LLM
import openvino_genai as ov_genai
from typing import List, Optional
from pydantic import BaseModel
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dotenv import load_dotenv
import os

# Load environment variables from a .env file
# This is used to securely store sensitive information like passwords
load_dotenv()

# Initialize OpenVINO LLM pipeline
# The model_path specifies the pre-trained model to use
# The device parameter specifies the hardware (e.g., NPU) for running the model
model_path = 'Phi-35_mini_instruct_refined'
pipe = ov_genai.LLMPipeline(model_path, device='NPU')

# Define a custom LLM class for OpenVINO
# This class integrates OpenVINO's LLM pipeline with LangChain's LLM interface
class OpenVINO_LLM(LLM):
    def __init__(self, pipeline: ov_genai.LLMPipeline, **kwargs):
        super().__init__(**kwargs)
        self._pipeline = pipeline

    # Property to access the pipeline
    @property
    def pipeline(self) -> ov_genai.LLMPipeline:
        return self._pipeline

    # Property to define the LLM type
    @property
    def _llm_type(self) -> str:
        return "openvino_genai"

    # Method to process a prompt and generate a response
    def _call(self, prompt: str, stop: Optional[List[str]] = None) -> str:
        response = []
        # Capture the output generated by the pipeline
        def capture_output(subword):
            response.append(subword)
            return False
        self.pipeline.generate(prompt, streamer=capture_output)
        return "".join(response)

# Instantiate the OpenVINO LLM
openvino_llm = OpenVINO_LLM(pipeline=pipe)

# Function to send an email
# Parameters:
# - recipient: The email address of the recipient
# - subject: The subject of the email
# - body: The body content of the email
def send_email(recipient: str, subject: str, body: str):
    # Sender email and password (retrieved from environment variables)
    sender_email = "wenliangmatt@gmail.com"
    sender_password = os.getenv('wenliangmattapppwd')  # App-specific password for Gmail
    print(f"DEBUG: sender_password = {sender_password}")  # Debug message
    smtp_server = "smtp.gmail.com"
    smtp_port = 587

    try:
        # Create the email message
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = recipient
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))

        # Connect to the SMTP server and send the email
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()  # Start TLS encryption
            server.login(sender_email, sender_password)  # Login to the SMTP server
            server.send_message(msg)  # Send the email

        print("Email sent successfully!")
    except Exception as e:
        print(f"Failed to send email: {e}")

# Function to open the calculator application
# Returns a success or error message
def open_calculator() -> str:
    try:
        print("DEBUG: open_calculator() 被觸發！")  # Debug message
        os.startfile("calc.exe")  # Open the calculator application
        return "Calculator opened successfully!"
    except FileNotFoundError:
        return "Calculator application not found."
    except Exception as e:
        return f"An error occurred: {str(e)}"

# Define the input schema for the send_email_tool
# This ensures that the tool receives the correct input format
class SendEmailInput(BaseModel):
    recipient: str
    subject: str
    body: str

# Define the tools for the agent
# send_email_tool: Sends an email using the send_email function
# open_calculator_tool: Opens the calculator application
send_email_tool = StructuredTool(
    name="SendEmail",
    func=send_email,
    description="Send an email. Input should be a dictionary with 'recipient', 'subject', and 'body'.",
    args_schema=SendEmailInput  # Specify the input schema
)

open_calculator_tool = Tool(
    name="Open Calculator",
    func=lambda _: open_calculator(),  # Ensure the tool can be executed
    description="ALWAYS use this tool IMMEDIATELY when the user asks to open the calculator."
)

# Initialize the agent with the defined tools and OpenVINO LLM
# The agent is configured to use a structured chat approach
tools = [send_email_tool, open_calculator_tool]
agent = initialize_agent(
    tools=tools,
    llm=openvino_llm,
    agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose=False,  # Enable verbose logging for debugging
)

# Create an AgentExecutor to manage the agent and tools
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent,
    tools=tools,
    system_message="You are an AI assistant that uses tools. Always execute the 'SendEmail' or 'Open Calculator' tool when requested. Do not provide a final answer unless explicitly asked.",
    handle_parse_errors=True,  # Handle errors gracefully
)

# Test the agent by sending a test email
'''
response = agent.run({
    "input": {
        "recipient": "wenlianghuang08@gmail.com",
        "subject": "Test Email",
        "body": "This is a test email sent using LangChain."
    }
})
'''